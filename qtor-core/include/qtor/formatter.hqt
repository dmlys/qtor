#pragma once
#include <cstddef>
#include <array>
#include <vector>
#include <unordered_map>
#include <qtor/types.hpp>

#include <QtCore/QObject>
#include <QtCore/QString>
#include <QtCore/QLocale>

#include <qtor/sparse_container.hpp>

namespace qtor
{
	class formatter : public QObject
	{
		Q_OBJECT;

	public:
		// weights
		enum weight : unsigned
		{
			none, kilo, mega, giga, tera
		};

	protected:
		static const std::array<uint64_type, 5> ms_weights;
		static const char * ms_size_strings[5];
		static const char * ms_speed_strings[5];
		static const char * ms_duration_strings[4];

		QLocale m_locale;

	public:
		void set_locale(QLocale loc) { m_locale = std::move(loc); }
		auto get_locale() const noexcept { return m_locale; }

	public:
		virtual auto weigh(double val) const noexcept -> weight;
		virtual auto weigh(double val, weight w) const noexcept -> double;
		virtual QString format_item(uint64_type val, const char *strings[5]) const;

	public:
		// more specialized formatters
		virtual QString format_size(size_type val) const;
		virtual QString format_speed(speed_type val) const;
		
		// more generic formatters
		virtual QString format_uint64(uint64_type val) const;
		virtual QString format_double(double val) const;
		virtual QString format_string(string_type val) const;
		virtual QString format_short_string(string_type val) const;
		
		virtual QString format_datetime(datetime_type val) const;
		virtual QString format_duration(duration_type val) const;

		virtual QString format_ratio(double val) const;
		virtual QString format_percent(double val) const;
		virtual QString format_bool(bool val) const;
		virtual QString format_nullopt() const;
		
	//public:
	//	virtual optional<std::tuple<unsigned, weight>> parse_suffix(const QString & str) const;
	//	virtual optional<std::tuple<unsigned, double, weight>> parse_numeric(const QString & str) const;

	//public:
	//	virtual optional<size_type>  parse_size(const QString & str) const;
	//	virtual optional<speed_type> parse_speed(const QString & str) const;

	//	virtual optional<uint64_type> parse_uint64(const QString & str) const;
	//	virtual optional<double>      parse_double(const QString & str) const;

	//	virtual optional<datetime_type> parse_datetime(const QString & str) const;
	//	virtual optional<duration_type> parse_duration(const QString & str) const;


	public:
#define QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(NAME, TYPE)                              \
		template <class Type>                                                         \
		std::enable_if_t<std::is_convertible_v<std::decay_t<Type>, TYPE>, QString>    \
		NAME(const optional<Type> & val) const                                        \
		{                                                                             \
			return val ? NAME(val.value()) : format_nullopt();                        \
		}                                                                             \
		                                                                              \
		QString NAME(const any & val) const                                           \
		{                                                                             \
			const auto * ptr = any_cast<TYPE>(&val);                                  \
			return ptr ? NAME(*ptr) : format_nullopt();                               \
		}                                                                             \


		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_speed,  speed_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_size,   size_type);
		
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_bool, bool);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_uint64, uint64_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_double, double);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_string, string_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_short_string, string_type);

		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_datetime, datetime_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_duration, duration_type);

		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_percent, double);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_ratio,   double);

#undef QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD

	public:
		using QObject::QObject;

	public:
		virtual ~formatter() = default;
	};




	class sparse_container_model_meta : public virtual sparse_container_meta
	{
	public:
		virtual QString item_name(index_type key) const = 0;
		virtual QString format_item(const sparse_container & cont, index_type key) const = 0;
		virtual QString format_item_short(const sparse_container & cont, index_type key) const = 0;

	public:
		~sparse_container_model_meta() = default;
	};


	template <class formatter = qtor::formatter>
	class simple_sparse_container_meta : 
		//public virtual sparse_container_meta,
		public virtual sparse_container_model_meta,
		public virtual formatter
	{
		using base_type = sparse_container_model_meta;
		using self_type = simple_sparse_container_meta;

	public:
		using formatter_type = formatter;
		using format_method  = QString(formatter_type::*)(const any_type &) const;

		struct item
		{
			unsigned type;
			QString name;
			format_method method;
		};

		using item_map     = std::unordered_map<index_type, item>;
		using item_map_ptr = std::shared_ptr<const item_map>;

	protected:
		item_map_ptr m_items;

	public:
		virtual index_type items_count() const noexcept override;
		virtual unsigned item_type(index_type key) const noexcept override;
		virtual  QString item_name(index_type key) const override;
		virtual  QString format_item(const sparse_container & cont, index_type key) const override;
		virtual  QString format_item_short(const sparse_container & cont, index_type key) const override;

	protected:
		simple_sparse_container_meta(QObject * parent = nullptr)
			: formatter_type(parent) {}

	public:
		simple_sparse_container_meta(item_map_ptr items)
			: m_items(std::move(items)) {}

		virtual ~simple_sparse_container_meta() = default;
	};

	template <class formatter>
	auto simple_sparse_container_meta<formatter>::items_count() const noexcept -> index_type
	{
		return static_cast<index_type>(m_items->size());
	}

	template <class formatter>
	unsigned simple_sparse_container_meta<formatter>::item_type(index_type key) const noexcept
	{
		auto it = m_items->find(key);
		if (it == m_items->end())
			return Unknown;

		return it->second.type;
	}

	template <class formatter>
	QString simple_sparse_container_meta<formatter>::item_name(index_type key) const
	{
		auto it = m_items->find(key);
		if (it == m_items->end())
			return QString::null;

		return it->second.name;
	}

	template <class formatter>
	QString simple_sparse_container_meta<formatter>::format_item(const sparse_container & cont, index_type key) const
	{
		auto it = m_items->find(key);
		if (it == m_items->end()) 
			return this->format_nullopt();

		auto method = it->second.method;
		const auto & val = cont.get_item(key);
		return (this->*method)(val);
	}

	template <class formatter>
	QString simple_sparse_container_meta<formatter>::format_item_short(const sparse_container & cont, index_type key) const
	{
		auto it = m_items->find(key);
		if (it == m_items->end())
			return this->format_nullopt();

		auto method = it->second.method;
		const auto & val = cont.get_item(key);

		decltype(method) short_string = &formatter_type::format_short_string;
		if (method == short_string)
			return (this->*short_string)(cont.get_item(key));

		return (this->*method)(val);
	}
}
