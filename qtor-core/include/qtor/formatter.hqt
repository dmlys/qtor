#pragma once
#include <cstddef>
#include <memory>
#include <array>
#include <vector>
#include <unordered_map>
#include <qtor/types.hpp>

#include <QtCore/QObject>
#include <QtCore/QString>
#include <QtCore/QLocale>

#include <qtor/sparse_container.hpp>

namespace qtor
{
	class formatter : public QObject
	{
		Q_OBJECT;

	public:
		// weights
		enum weight : unsigned
		{
			none, kilo, mega, giga, tera
		};

	protected:
		static const std::array<uint64_type, 5> ms_weights;
		static const char * ms_size_strings[5];
		static const char * ms_speed_strings[5];
		static const char * ms_duration_strings[4];

		QLocale m_locale;

	public:
		void set_locale(QLocale loc) { m_locale = std::move(loc); }
		auto get_locale() const noexcept { return m_locale; }

	public:
		virtual auto weigh(double val) const noexcept -> weight;
		virtual auto weigh(double val, weight w) const noexcept -> double;
		virtual QString format_item(uint64_type val, const char *strings[5]) const;

	public:
		// more specialized formatters
		virtual QString format_size(size_type val) const;
		virtual QString format_speed(speed_type val) const;
		
		// more generic formatters
		virtual QString format_int64(int64_type val) const;
		virtual QString format_uint64(uint64_type val) const;
		virtual QString format_double(double val) const;
		virtual QString format_string(string_type val) const;
		virtual QString format_short_string(string_type val) const;
		
		virtual QString format_datetime(datetime_type val) const;
		virtual QString format_duration(duration_type val) const;

		virtual QString format_ratio(double val) const;
		virtual QString format_percent(double val) const;
		virtual QString format_bool(bool val) const;
		virtual QString format_nullopt() const;

	public:
#define QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(NAME, TYPE)                              \
		template <class Type>                                                         \
		std::enable_if_t<std::is_convertible_v<std::decay_t<Type>, TYPE>, QString>    \
		NAME(const optional<Type> & val) const                                        \
		{                                                                             \
			return val ? NAME(val.value()) : format_nullopt();                        \
		}                                                                             \
		                                                                              \
		QString NAME(const any & val) const                                           \
		{                                                                             \
			const auto * ptr = any_cast<TYPE>(&val);                                  \
			return ptr ? NAME(*ptr) : format_nullopt();                               \
		}                                                                             \


		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_speed,  speed_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_size,   size_type);
		
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_bool, bool);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_uint64, uint64_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_double, double);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_string, string_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_short_string, string_type);

		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_datetime, datetime_type);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_duration, duration_type);

		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_percent, double);
		QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD(format_ratio,   double);

#undef QTOR_FORMATTER_OPTIONAL_ANY_OVERLOAD

	public:
		using QObject::QObject;

	public:
		virtual ~formatter() = default;
	};




	class sparse_container_model_meta : 
		public virtual sparse_container_meta,
		public virtual formatter
	{
	public:
		using formatter::format_item;

	public:
		virtual QString item_name(index_type key) const = 0;
		virtual QString format_item(const sparse_container & cont, index_type key) const = 0;
		virtual QString format_item_short(const sparse_container & cont, index_type key) const = 0;

	public:
		~sparse_container_model_meta() = default;
	};


	class simple_sparse_container_meta : public virtual sparse_container_model_meta
	{
		using base_type = sparse_container_model_meta;
		using self_type = simple_sparse_container_meta;

	public:
		using formatter_type = qtor::formatter;
		using format_method  = QString(formatter_type::*)(const any_type &) const;

		struct item
		{
			unsigned type;
			QString name;
			format_method method;
		};

		using item_map     = std::unordered_map<index_type, item>;
		using item_map_ptr = std::shared_ptr<const item_map>;

	protected:
		item_map_ptr m_items;

	public:
		virtual index_type items_count() const noexcept override;
		virtual unsigned item_type(index_type key) const noexcept override;
		virtual  QString item_name(index_type key) const override;
		virtual  QString format_item(const sparse_container & cont, index_type key) const override;
		virtual  QString format_item_short(const sparse_container & cont, index_type key) const override;

	protected:
		simple_sparse_container_meta(QObject * parent = nullptr)
			: formatter_type(parent) {}

	public:
		simple_sparse_container_meta(item_map_ptr items)
			: m_items(std::move(items)) {}

		virtual ~simple_sparse_container_meta() = default;
	};
}
