#pragma once
#include <qtor/types.hpp>
#include <qtor/torrent.hpp>
#include <qtor/torrent_file_store.hpp>
#include <qtor/AbstractFileTreeModel.hqt>
#include <qtor/sftree_view_qtbase.hpp>
#include <qtor/sftree_model_qtbase.hpp>

namespace qtor
{
	struct torrent_file_tree_traits
	{
		using path_type = filepath_type;
		using pathview_type = QStringRef;

		using path_equal_to = std::equal_to<path_type>;
		using path_less     = std::less<path_type>;
		using path_hasher   = std::hash<path_type>;

		struct node_type;
		using leaf_type = torrent_file;

		struct node_type
		{
			filepath_type  name;
			size_type      total_size;
			size_type      have_size;
			int_type       priority;
			Qt::CheckState wanted;
		};

		static void set_segment(node_type & node, path_type && path) { node.name = std::move(path); }
		static path_type get_segment(const path_type & name);
		static path_type get_segment(const leaf_type & leaf) { return get_segment(leaf.filename); }
		static path_type get_segment(const node_type & node) { return get_segment(node.name); }
		static path_type get_path(const leaf_type & leaf)    { return leaf.filename; }

		static bool is_subelement(const pathview_type & prefix, const path_type & name, const torrent_file & item);
		static auto analyze(const pathview_type & prefix, const leaf_type & item) 
			-> std::tuple<std::uintptr_t, path_type, pathview_type>;

		class column_sorter
		{
			using leaf_compare_function = bool(*)(const leaf_type & l1, const leaf_type & l2) noexcept;
			using node_compare_function = bool(*)(const node_type & l1, const node_type & l2) noexcept;

			leaf_compare_function m_leaf_compare;
			node_compare_function m_node_compare;

			template <class Entity, class Type, Type Entity::*member, class Pred>
			static bool compare_entity(const Entity & e1, const Entity & e2) noexcept;

		public:
			void reset(unsigned type, Qt::SortOrder order);

		public:
			inline bool operator()(const node_type & p1, const node_type & p2) const noexcept { return m_node_compare(p1, p2); }
			inline bool operator()(const node_type & p1, const leaf_type & l2) const noexcept { return true; }
			inline bool operator()(const leaf_type & l1, const leaf_type & l2) const noexcept { return m_leaf_compare(l1, l2); }
			inline bool operator()(const leaf_type & l1, const node_type & p2) const noexcept { return false; }

		public:
			column_sorter() : column_sorter(torrent_file::FileName, Qt::AscendingOrder) {}
			column_sorter(unsigned type, Qt::SortOrder order) { reset(type, order); }
		};

		class filepath_filter
		{
			filepath_type m_filterStr;

		public:
			viewed::refilter_type set_expr(QString expr);

			bool always_matches() const { return m_filterStr.isEmpty(); }
			bool matches(const filepath_type & name) const;

			inline bool operator()(const filepath_type & name) const noexcept { return matches(name); }
			inline bool operator()(const leaf_type & l) const noexcept { return matches(get_segment(l)); }
			inline bool operator()(const node_type & p) const noexcept { return matches(get_segment(p)); }
			inline explicit operator bool() const { return not always_matches(); }
		};

		using sort_pred_type = column_sorter;
		using filter_pred_type = filepath_filter;
	};


	class FileTreeModel : public viewed::sftree_model_qtbase<torrent_file_tree_traits, AbstractFileTreeModel>
	//class FileTreeModel : public viewed::sftree_view_qtbase<torrent_file_tree_traits, torrent_file_store, AbstractFileTreeModel>
	{
		using self_type = FileTreeModel;
		using base_type = viewed::sftree_model_qtbase<torrent_file_tree_traits, AbstractFileTreeModel>;
		using view_type = viewed::sftree_model_qtbase<torrent_file_tree_traits, AbstractFileTreeModel>;
		//using base_type = viewed::sftree_view_qtbase<torrent_file_tree_traits, torrent_file_store, AbstractFileTreeModel>;
		//using view_type = viewed::sftree_view_qtbase<torrent_file_tree_traits, torrent_file_store, AbstractFileTreeModel>;

	protected:
		struct get_total_size_type
		{
			template <class Type>
			auto operator()(const Type * item)      const { return item->total_size; }
			auto operator()(const value_ptr & item) const { return viewed::visit(*this, item); }
		};

		struct get_have_size_type
		{
			template <class Type>
			auto operator()(const Type * item)      const { return item->have_size; }
			auto operator()(const value_ptr & item) const { return viewed::visit(*this, item); }
		};

		struct get_wanted_type
		{
			Qt::CheckState operator()(const leaf_type * item) const { return item->wanted ? Qt::Checked : Qt::Unchecked; }
			Qt::CheckState operator()(const page_type * item) const { return item->wanted; }
			Qt::CheckState operator()(const value_ptr & item) const { return viewed::visit(*this, item); }
		};

	protected:
		//using view_type::get_segment;
		static constexpr get_total_size_type     get_total_size {};
		static constexpr get_have_size_type      get_have_size {};
		static constexpr get_wanted_type         get_wanted {};
		static constexpr get_children_type       get_children {};
		static constexpr get_children_count_type get_children_count {};

	protected:
		void recalculate_page(page_type & page) override;

	protected:
		virtual void SortBy(int column, Qt::SortOrder order) override;
		virtual void FilterBy(QString expr) override;

	public:
		//virtual Qt::ItemFlags flags(const QModelIndex & index) const override;
		//virtual QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const override;
		//virtual QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
		
		virtual QVariant GetItem(const QModelIndex & idx)  const override;
		virtual QString  GetValue(const QModelIndex & idx)  const override;
		virtual QString  GetValueShort(const QModelIndex & idx) const override;

	public:
		//FileTreeModel(std::shared_ptr<torrent_file_store> store, QObject * parent = nullptr);
		FileTreeModel(QObject * parent = nullptr);
	};
}
