#pragma once
#include <qtor/types.hpp>
#include <qtor/torrent.hpp>
#include <qtor/torrent_file_store.hpp>
#include <qtor/AbstractFileTreeModel.hqt>
#include <qtor/sftree_view_qtbase.hpp>
#include <qtor/sftree_model_qtbase.hpp>

namespace qtor
{
	struct torrent_file_tree_traits
	{
		using path_type = filepath_type;
		using pathview_type = filepath_type;

		using path_equal_to_type = std::equal_to<>;
		using path_less_type     = std::less<>;
		using path_hash_type     = std::hash<path_type>;

		struct node_type;
		using leaf_type = torrent_file;

		struct node_type
		{
			path_type      name;
			size_type      total_size;
			size_type      have_size;
			int_type       priority;
			Qt::CheckState wanted;
		};

		static void set_name(node_type & node, const pathview_type & path, const pathview_type & name) { node.name = name; }
		static path_type get_name(const path_type & name);
		static path_type get_name(const leaf_type & leaf) { return get_name(leaf.filename); }
		static path_type get_name(const node_type & node) { return get_name(node.name); }
		static path_type get_path(const leaf_type & leaf) { return leaf.filename; }

		static bool is_child(const pathview_type & path, const pathview_type & name, const pathview_type & leaf_path);
		static auto analyze(const pathview_type & path, const pathview_type & leaf_path)
		    -> std::tuple<std::uintptr_t, pathview_type, pathview_type>;

		// fix for QString to QStringRef conversion
		//static bool is_child(const pathview_type & path, const pathview_type & name, const path_type & leaf_path)
		//{ return is_child(path, name, &leaf_path); }
		//static auto analyze(const pathview_type & path, const path_type & leaf_path)
		//    -> std::tuple<std::uintptr_t, pathview_type, pathview_type>
		//{ return analyze(path, &leaf_path); }

		class column_sorter
		{
			using leaf_compare_function = bool(*)(const leaf_type & l1, const leaf_type & l2) noexcept;
			using node_compare_function = bool(*)(const node_type & l1, const node_type & l2) noexcept;

			leaf_compare_function m_leaf_compare;
			node_compare_function m_node_compare;

			template <class Entity, class Type, Type Entity::*member, class Pred>
			static bool compare_entity(const Entity & e1, const Entity & e2) noexcept;

		public:
			void reset(unsigned type, Qt::SortOrder order);

		public:
			inline bool operator()(const node_type & p1, const node_type & p2) const noexcept { return m_node_compare(p1, p2); }
			inline bool operator()(const node_type & p1, const leaf_type & l2) const noexcept { return true; }
			inline bool operator()(const leaf_type & l1, const leaf_type & l2) const noexcept { return m_leaf_compare(l1, l2); }
			inline bool operator()(const leaf_type & l1, const node_type & p2) const noexcept { return false; }

		public:
			column_sorter() : column_sorter(torrent_file::FileName, Qt::AscendingOrder) {}
			column_sorter(unsigned type, Qt::SortOrder order) { reset(type, order); }
		};

		class filepath_filter
		{
			filepath_type m_filterStr;

		public:
			viewed::refilter_type set_expr(QString expr);

			bool always_matches() const { return m_filterStr.isEmpty(); }
			bool matches(const filepath_type & name) const;

			inline bool operator()(const filepath_type & name) const noexcept { return matches(name); }
			inline bool operator()(const leaf_type & l) const noexcept { return matches(get_name(l)); }
			inline bool operator()(const node_type & p) const noexcept { return matches(get_name(p)); }
			inline explicit operator bool() const { return not always_matches(); }
		};

		using sort_pred_type = column_sorter;
		using filter_pred_type = filepath_filter;
	};


	class FileTreeModel : public viewed::sftree_model_qtbase<torrent_file_tree_traits, AbstractFileTreeModel>
	//class FileTreeModel : public viewed::sftree_view_qtbase<torrent_file_tree_traits, torrent_file_store, AbstractFileTreeModel>
	{
		using self_type = FileTreeModel;
		using base_type = viewed::sftree_model_qtbase<torrent_file_tree_traits, AbstractFileTreeModel>;
		using view_type = viewed::sftree_model_qtbase<torrent_file_tree_traits, AbstractFileTreeModel>;
		//using base_type = viewed::sftree_view_qtbase<torrent_file_tree_traits, torrent_file_store, AbstractFileTreeModel>;
		//using view_type = viewed::sftree_view_qtbase<torrent_file_tree_traits, torrent_file_store, AbstractFileTreeModel>;

	protected:
		struct get_total_size_type
		{
			template <class Type>
			auto operator()(const Type * item)      const { return item->total_size; }
			auto operator()(const value_ptr & item) const { return viewed::visit(*this, item); }
		};

		struct get_have_size_type
		{
			template <class Type>
			auto operator()(const Type * item)      const { return item->have_size; }
			auto operator()(const value_ptr & item) const { return viewed::visit(*this, item); }
		};

		struct get_wanted_type
		{
			Qt::CheckState operator()(const leaf_type * item) const { return item->wanted ? Qt::Checked : Qt::Unchecked; }
			Qt::CheckState operator()(const page_type * item) const { return item->wanted; }
			Qt::CheckState operator()(const value_ptr & item) const { return viewed::visit(*this, item); }
		};

	protected:
		//using view_type::get_segment;
		static constexpr get_total_size_type     get_total_size {};
		static constexpr get_have_size_type      get_have_size {};
		static constexpr get_wanted_type         get_wanted {};
		static constexpr get_children_type       get_children {};
		static constexpr get_children_count_type get_children_count {};

	protected:
		void recalculate_page(page_type & page) override;

	protected:
		virtual void SortBy(int column, Qt::SortOrder order) override;
		virtual void FilterBy(QString expr) override;

	public:
		using base_type::path_group_pred;
		//virtual Qt::ItemFlags flags(const QModelIndex & index) const override;
		//virtual QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const override;
		//virtual QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
		
		virtual QVariant GetItem(const QModelIndex & idx)  const override;
		virtual QString  GetValue(const QModelIndex & idx)  const override;
		virtual QString  GetValueShort(const QModelIndex & idx) const override;

	public:
		//FileTreeModel(std::shared_ptr<torrent_file_store> store, QObject * parent = nullptr);
		FileTreeModel(QObject * parent = nullptr);
	};
}
