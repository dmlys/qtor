#pragma once
#include <variant>
#include <vector>

#include <qtor/types.hpp>
#include <qtor/torrent.hpp>
#include <qtor/torrent_file_store.hpp>

#include <viewed/algorithm.hpp>
#include <viewed/refilter_type.hpp>
#include <viewed/indirect_functor.hpp>
#include <viewed/sfview_qtbase.hpp>

#include <QtCore/QString>
#include <QtCore/QAbstractItemModel>

#include <boost/integer/static_log2.hpp>
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/hashed_index.hpp>
#include <boost/multi_index/random_access_index.hpp>


namespace qtor
{
	class FileTreeModel : public QAbstractItemModel
	{
		using base_type = QAbstractItemModel;

	public:
		using container_type = torrent_file_store;

	protected:
		// store <-> view exchange
		using torrent_file_ptr = container_type::view_pointer_type;
		static_assert(std::is_pointer_v<torrent_file_ptr>);

		using signal_range_type = typename container_type::signal_range_type;
		using scoped_connection = typename container_type::scoped_connection;

		static     torrent_file_ptr get_view_pointer(const torrent_file & val) { return container_type::get_view_pointer(val); }
		static const torrent_file & get_view_reference(torrent_file_ptr ptr)   { return container_type::get_view_reference(ptr); }

	protected:
		struct page_type;
		union  value_ptr;

		using leaf_type = torrent_file;
		using int_vector = std::vector<int>;

		using value_ptr_vector = std::vector<const value_ptr *>;
		using value_ptr_iterator = value_ptr_vector::iterator;

		static constexpr std::uintptr_t PAGE = 0;
		static constexpr std::uintptr_t LEAF = 1;
		
		static_assert(boost::static_log2<sizeof(std::max_align_t)>::value >= 2);

		// page_ptr or leaf_ptr
		union value_ptr
		{
			struct
			{
				std::uintptr_t ptr    : sizeof(std::uintptr_t) * CHAR_BIT - 2;
				std::uintptr_t type   : 1; // 1 - leaf_ptr, 0 - page_ptr
				std::uintptr_t owning : 1; // 1 - owning,   0 - non owning
			};

			std::uintptr_t val;

		public:
			template <class visitor>
			auto visit(visitor && vis) const -> std::invoke_result_t<visitor, const leaf_type *>;

		protected:
			void destroy() noexcept;

		public:
			value_ptr(const leaf_type * ptr) noexcept;
			value_ptr(const page_type * ptr) noexcept;

			value_ptr & operator =(const leaf_type * ptr) noexcept;
			value_ptr & operator =(const page_type * ptr) noexcept;

			template <class Type> value_ptr(std::unique_ptr<Type> ptr) noexcept;
			template <class Type> value_ptr & operator =(std::unique_ptr<Type> ptr) noexcept;

		public:
			value_ptr(value_ptr &&) noexcept;
			value_ptr & operator =(value_ptr &&) noexcept;

			value_ptr(const value_ptr &) = delete;
			value_ptr & operator =(const value_ptr &) = delete;

			value_ptr() noexcept;
			~value_ptr() noexcept;
		};


		struct get_name_type
		{
			using result_type = filepath_type;
			result_type operator()(const leaf_type * lead) const;
			result_type operator()(const page_type * lead) const;
			result_type operator()(const value_ptr & val)  const;
		};

		using value_container = boost::multi_index_container<
			value_ptr, 
			boost::multi_index::indexed_by<
				boost::multi_index::hashed_unique<get_name_type>,
				boost::multi_index::random_access<>
			>
		>;

		static constexpr int by_code = 0;
		static constexpr int by_seq  = 1;

		using code_view_type = value_container::nth_index<by_code>::type;
		using seq_view_type  = value_container::nth_index<by_seq>::type;

		struct page_type
		{
			page_type *     parent  = nullptr;
			std::size_t     upassed = 0;
			value_container children;

			filepath_type  name;
			size_type      total_size;
			size_type      have_size;
			Qt::CheckState wanted;
		};

		struct get_children_type
		{
			using result_type = const value_container &;
			result_type operator()(const leaf_type * leaf) const { return ms_empty_container; }
			result_type operator()(const page_type * page) const { return page->children; }
			result_type operator()(const value_ptr & val)  const { return val.visit(*this); }
		};

		struct get_children_count_type
		{
			using result_type = std::size_t;
			result_type operator()(const leaf_type * leaf) const { return 0; }
			result_type operator()(const page_type * page) const { return page->upassed; }
			result_type operator()(const value_ptr & val)  const { return val.visit(*this); }
		};

		struct processing_context
		{
			signal_range_type::const_iterator 
				inserted_first, inserted_last,
				updated_first,  updated_last,
				erased_first,   erased_last;

			int_vector::iterator
				changed_first, changed_last,
				removed_first, removed_last;

			QStringRef prefix;
			QModelIndexList * indexes;
		};

		struct dirs_first_sorter
		{
			bool operator()(const value_ptr & p1, const value_ptr & p2) const noexcept
			{
				return p1.type < p2.type;
			}
		};

	protected:
		static constexpr get_name_type           get_name {};
		static constexpr get_children_type       get_children {};
		static constexpr get_children_count_type get_children_count {};

	protected:
		static const value_container ms_empty_container;

	protected:
		std::shared_ptr<container_type> m_owner = nullptr; // pointer to owning container
		page_type m_root; //= { /*.parent =*/ nullptr};		

		dirs_first_sorter m_sorter;
		viewed::null_filter m_filter;
		//viewed::null_sorter m_sorter;

		/// raii connections
		scoped_connection m_clear_con;
		scoped_connection m_update_con;
		scoped_connection m_erase_con;

	protected:
		static auto analyze(const QStringRef & prefix, const torrent_file & item)
			-> std::tuple<std::uintptr_t, QString, QStringRef>;

		static bool is_subelement(const QStringRef & prefix, const QString & name, const torrent_file & item);
		static auto copy_context(const processing_context & ctx, QStringRef newprefix) -> processing_context;

		template <class ForwardIterator>
		void fill_page(page_type & page, QStringRef prefix, ForwardIterator first, ForwardIterator last);		

		virtual auto process_erased(page_type & page, processing_context & ctx) -> std::tuple<QString, QStringRef>;
		virtual auto process_updated(page_type & page, processing_context & ctx) -> std::tuple<QString, QStringRef>;
		virtual auto process_inserted(page_type & page, processing_context & ctx) -> std::tuple<QString, QStringRef>;
		virtual void update_page(page_type & page, processing_context & ctx);

		virtual void sort_children(page_type & page);

	protected:
		/// container event handlers, those are called on container signals,
		/// you could reimplement them to provide proper handling of your view
		
		/// called when new data is updated in owning container
		/// view have to synchronize itself.
		/// @Param sorted_newrecs range of pointers to updated records, sorted by pointer value
		/// 
		/// default implementation removes erased, appends inserted records, and does nothing with sorted_updated
		virtual void update_data(
			const signal_range_type & sorted_erased,
			const signal_range_type & sorted_updated,
			const signal_range_type & inserted);

		/// called when some records are erased from container
		/// view have to synchronize itself.
		/// @Param sorted_newrecs range of pointers to updated records, sorted by pointer value
		/// 
		/// default implementation, erases those records from main store
		virtual void erase_records(const signal_range_type & sorted_erased);

		/// called when container is cleared, clears m_store.
		virtual void clear_view();
		
		/// connects container signals to appropriate handlers
		virtual void connect_signals();

	protected:
		/// adjusts view with erased/updated/inserted data, preserving filter/sort order. stable,
		/// new and updated should already be appended to m_store in order: current data..., updated..., inserted...].
		/// emits appropriate qt signals, uses merge_newdata(iter..., iter..., ...) to calculate index permutations.
		//virtual void update_store(
		//	store_iterator first, store_iterator first_updated,
		//	store_iterator first_inserted, store_iterator last,
		//	signal_const_iterator first_erased, signal_const_iterator last_erased);

		/// merges m_store's [middle, last) into [first, last) according to m_sort_pred. stable.
		/// first, middle, last - is are one range, as in std::inplace_merge
		/// if resort_old is true it also resorts [first, middle), otherwise it's assumed it's sorted
		//virtual void merge_newdata(
		//	store_iterator first, store_iterator middle, store_iterator last,
		//	bool resort_old = true);

		/// merges m_store's [middle, last) into [first, last) according to m_sort_pred. stable.
		/// first, middle, last - is are one range, as in std::inplace_merge
		/// if resort_old is true it also resorts [first, middle), otherwise it's assumed it's sorted
		/// 
		/// range [ifirst, imiddle, ilast) must be permuted the same way as range [first, middle, last)
		//virtual void merge_newdata(
		//	store_iterator first, store_iterator middle, store_iterator last,
		//	int_vector::iterator ifirst, int_vector::iterator imiddle, int_vector::iterator ilast,
		//	bool resort_old = true);

		/// sorts m_store's [first; last) with m_sort_pred, stable sort
		//virtual void sort(value_ptr_iterator first, value_ptr_iterator last);
		/// sorts m_store's [first; last) with m_sort_pred, stable sort
		/// range [ifirst; ilast) must be permuted the same way as range [first; last)
		//virtual void sort(value_ptr_iterator first, value_ptr_iterator last,
		//                  int_vector::iterator ifirst, int_vector::iterator ilast);

		/// sorts m_store's [first; last) with m_sort_pred, stable sort
		/// emits qt layoutAboutToBeChanged(..., VerticalSortHint), layoutUpdated(..., VerticalSortHint)
		//virtual void sort_and_notify();

		/// refilters m_store with m_filter_pred according to rtype:
		/// * same        - does nothing and immediately returns(does not emit any qt signals)
		/// * incremental - calls refilter_full_and_notify
		/// * full        - calls refilter_incremental_and_notify
		//virtual void refilter_and_notify(viewed::refilter_type rtype);
		/// removes elements not passing m_filter_pred from m_store
		/// emits qt layoutAboutToBeChanged(..., NoLayoutChangeHint), layoutUpdated(..., NoLayoutChangeHint)
		//virtual void refilter_incremental_and_notify();
		/// fills m_store from owner with values passing m_filter_pred and sorts them according to m_sort_pred
		/// emits qt layoutAboutToBeChanged(..., NoLayoutChangeHint), layoutUpdated(..., NoLayoutChangeHint)
		//virtual void refilter_full_and_notify();

	public:
		/// returns pointer to owning container
		const auto & get_owner() const noexcept { return m_owner; }

		/// reinitializes view
		/// default implementation just copies from owner
		virtual void reinit_view();

		/// normally should not be called outside of view class.
		/// Provided, when view class used directly without inheritance, to complete initialization.
		/// Calls connects signals and calls reinit_view.
		/// 
		/// Derived views probably will automatically call it constructor
		/// or directly connect_signals/reinit_view
		virtual void init();

	protected:
		page_type * get_page(const QModelIndex & index) const;
		const value_ptr & get_element_ptr(const QModelIndex & index) const;
		QModelIndex createIndex(int row, int column, page_type * ptr) const { return base_type::createIndex(row, column, ptr); }

	public:
		virtual int rowCount(const QModelIndex & parent = QModelIndex()) const override;
		virtual int columnCount(const QModelIndex & parent = QModelIndex()) const override;
		virtual QModelIndex parent(const QModelIndex & index) const override;
		virtual QModelIndex index(int row, int column, const QModelIndex & parent = QModelIndex()) const override;

		//virtual Qt::ItemFlags flags(const QModelIndex & index) const override;
		virtual QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const override;
		virtual QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

	protected:
		void fill_page(page_type & page, QStringRef prefix,
			std::vector<torrent_file>::const_iterator first, 
			std::vector<torrent_file>::const_iterator last);

	public:
		FileTreeModel(std::shared_ptr<torrent_file_store> store, QObject * parent = nullptr);
	};

	template <class visitor>
	inline auto FileTreeModel::value_ptr::visit(visitor && vis) const
		-> std::invoke_result_t<visitor, const leaf_type *>
	{
		return this->type == LEAF
			? std::forward<visitor>(vis)(reinterpret_cast<const leaf_type *>(ptr))
			: std::forward<visitor>(vis)(reinterpret_cast<const page_type *>(ptr));
	}

	template <class visitor>
	inline auto visit(const FileTreeModel::value_ptr & val, visitor && vis)
		-> std::invoke_result_t<visitor, const FileTreeModel::leaf_type *>
	{
		return val.visit(std::forward<visitor>(vis));
	}
}
