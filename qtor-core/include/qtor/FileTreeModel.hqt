#pragma once
#include <qtor/types.hpp>
#include <qtor/torrent.hpp>
#include <qtor/torrent_file_store.hpp>
#include <qtor/AbstractFileTreeModel.hqt>
#include <qtor/sftree_view_qtbase.hpp>
#include <qtor/sftree_model_qtbase.hpp>

namespace qtor
{
	class SimpleTextFilter
	{
		QString m_filterWord;

	public:
		viewed::refilter_type set_expr(QString expr);

		bool always_matches() const { return m_filterWord.isEmpty(); }
		bool matches(const QString & rec) const;

		inline bool operator()(const QString & rec) const { return matches(rec); }
		inline explicit operator bool() const { return not always_matches(); }
	};


	struct FileTreeModelTraits
	{
		using path_type = filepath_type;
		using pathview_type = QStringRef;

		using path_equal_to = std::equal_to<path_type>;
		using path_less     = std::less<path_type>;
		using path_hasher   = std::hash<path_type>;

		struct node_type;
		using leaf_type = torrent_file;

		struct node_type
		{
			filepath_type  name;
			size_type      total_size;
			size_type      have_size;
			Qt::CheckState wanted;
		};

		static void set_segment(node_type & node, path_type && path) { node.name = std::move(path); }
		static path_type get_segment(const path_type & name);
		static path_type get_segment(const leaf_type & leaf) { return get_segment(leaf.filename); }
		static path_type get_segment(const node_type & node) { return get_segment(node.name); }
		static path_type get_path(const leaf_type & leaf)    { return leaf.filename; }

		struct dirs_first_sorter
		{
			bool operator()(const node_type & p1, const node_type & p2) const noexcept { return get_segment(p1) < get_segment(p2); }
			bool operator()(const node_type & p1, const leaf_type & l2) const noexcept { return true; }
			bool operator()(const leaf_type & l1, const leaf_type & l2) const noexcept { return get_segment(l1) < get_segment(l2); }
			bool operator()(const leaf_type & l1, const node_type & p2) const noexcept { return false; }
		};

		struct test_filter
		{
			bool operator()(const leaf_type & l) const noexcept { return m_tfilt(get_segment(l)); }
			bool operator()(const node_type & p) const noexcept { return m_tfilt(get_segment(p)); }
			explicit operator bool() const noexcept { return static_cast<bool>(m_tfilt); }
		};

		using sort_pred_type = dirs_first_sorter;
		using filter_pred_type = test_filter;

		static SimpleTextFilter m_tfilt;
	};


	class FileTreeModel : public viewed::sftree_model_qtbase<FileTreeModelTraits, AbstractFileTreeModel>
	//class FileTreeModel : public viewed::sftree_view_qtbase<FileTreeModelTraits, torrent_file_store, AbstractFileTreeModel>
	{
		using self_type = FileTreeModel;
		using base_type = viewed::sftree_model_qtbase<FileTreeModelTraits, AbstractFileTreeModel>;
		using view_type = viewed::sftree_model_qtbase<FileTreeModelTraits, AbstractFileTreeModel>;
		//using base_type = viewed::sftree_view_qtbase<FileTreeModelTraits, torrent_file_store, AbstractFileTreeModel>;
		//using view_type = viewed::sftree_view_qtbase<FileTreeModelTraits, torrent_file_store, AbstractFileTreeModel>;

	protected:
		struct get_total_size_type
		{
			template <class Type>
			auto operator()(const Type * item)      const { return item->total_size; }
			auto operator()(const value_ptr & item) const { return viewed::pv_visit(*this, item); }
		};

		struct get_have_size_type
		{
			template <class Type>
			auto operator()(const Type * item)      const { return item->have_size; }
			auto operator()(const value_ptr & item) const { return viewed::pv_visit(*this, item); }
		};

		struct get_wanted_type
		{
			Qt::CheckState operator()(const leaf_type * item) const { return item->wanted ? Qt::Checked : Qt::Unchecked; }
			Qt::CheckState operator()(const page_type * item) const { return item->wanted; }
			Qt::CheckState operator()(const value_ptr & item) const { return viewed::pv_visit(*this, item); }
		};

	protected:
		//using view_type::get_segment;
		static constexpr get_total_size_type     get_total_size {};
		static constexpr get_have_size_type      get_have_size {};
		static constexpr get_wanted_type         get_wanted {};
		static constexpr get_children_type       get_children {};
		static constexpr get_children_count_type get_children_count {};

	protected:
		bool is_subelement(const pathview_type & prefix, const path_type & name, const torrent_file & item) override;
		auto analyze(const pathview_type & prefix, const leaf_type & item)
			-> std::tuple<std::uintptr_t, path_type, pathview_type> override;

		void recalculate_page(page_type & page) override;

	protected:
		virtual void SortBy(int column, Qt::SortOrder order) override;
		virtual void FilterBy(QString expr) override;

	public:
		//virtual Qt::ItemFlags flags(const QModelIndex & index) const override;
		//virtual QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const override;
		//virtual QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;
		
		virtual QVariant GetItem(const QModelIndex & idx)  const override;
		virtual QString  GetValue(const QModelIndex & idx)  const override;
		virtual QString  GetValueShort(const QModelIndex & idx) const override;

	public:
		//FileTreeModel(std::shared_ptr<torrent_file_store> store, QObject * parent = nullptr);
		FileTreeModel(QObject * parent = nullptr);
	};
}
